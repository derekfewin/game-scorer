<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Game Night Scorer</title>
    <style>
        :root { 
            --primary: #2c3e50; 
            --accent: #27ae60; 
            --light: #f4f7f6; 
            --gold: #f1c40f; 
            --danger: #c0392b; 
            --dealer-bg: #e8f4fd;
            /* Game Colors */
            --c-shanghai: #27ae60; 
            --c-mexicantrain: #d35400; 
            --c-oldhell: #8e44ad; 
            --c-qwirkle: #e74c3c; 
            --c-spades: #2c3e50; 
            --c-hearts: #c0392b;
            --c-rummikub: #2980b9; 
            --c-triominos: #f39c12;
        }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--light); padding: 10px; margin: 0; }
        .card { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); max-width: 600px; margin: auto; }
        
        /* Setup Screens */
        .setup-group { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        label { display: block; font-weight: bold; margin-bottom: 5px; color: var(--primary); }
        select, input { width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box; margin-bottom: 8px; background: #fff; }
        
        button { color: white; border: none; padding: 15px; width: 100%; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; margin-top: 10px; transition: opacity 0.2s; }
        button:active { opacity: 0.8; }

        .btn-game-action { background-color: var(--primary); } 
        .btn-restore { background: #f39c12; margin-bottom: 20px; }
        .btn-outline { background: transparent; color: var(--danger); border: 2px solid var(--danger); margin-top: 5px; }
        .btn-info { background: #3498db; margin-bottom: 10px; }
        .btn-undo { background: #7f8c8d; font-size: 0.9em; padding: 10px; margin-top: 20px; }
        .btn-exit { background: #95a5a6; margin-top: 20px; } 

        /* Table */
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background: white; table-layout: fixed; }
        th, td { border: 1px solid #eee; padding: 8px; text-align: center; overflow: hidden; font-size: 13px; vertical-align: middle; }
        th { background: #2c3e50; color: white; font-size: 0.9em; white-space: nowrap; } 
        th:first-child { width: 30px; } 
        
        /* Game Specific Column Widths */
        .game-shanghai th:nth-child(2) { width: 150px; } 
        .game-oldhell th:first-child { width: 70px; } 
        .game-oldhell th:nth-child(2) { width: 50px; } 

        .contract-text { font-size: 0.85em; line-height: 1.3; white-space: nowrap; }
        .winner-cell { background: #d4edda !important; font-weight: bold; color: #155724; }
        
        .history-dealer { border: 2px solid #3498db !important; }
        .history-star { color: #f39c12; font-size: 0.8em; margin-left: 2px; }
        
        /* Headers */
        .game-header { text-align: center; margin-bottom: 15px; }
        .round-title { font-size: 1.1em; color: var(--primary); font-weight: bold; }
        .hero-display { font-size: 1.5em; font-weight: 800; text-align: center; text-transform: uppercase; color: var(--primary); line-height: 1.2; }

        /* TEAM WRAPPER STYLES */
        .team-block { background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 10px; padding: 10px; margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .team-block-header { font-size: 1.1em; color: var(--primary); font-weight: 800; text-transform: uppercase; margin-bottom: 10px; border-bottom: 2px solid #e9ecef; padding-bottom: 5px; }
        .team-goal-display { font-size: 1.3em; color: #2c3e50; margin-bottom: 8px; text-align: center; font-weight: 800; background: #fff; padding: 8px; border-radius: 6px; border: 1px dashed #ccc; line-height: 1.2; }

        /* Inputs */
        .input-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; background: #fff; padding: 12px; border-radius: 8px; border: 1px solid #eee; }
        .input-left-col { flex: 1; display: flex; align-items: center; padding-right: 10px; overflow: hidden; }
        .input-text-group { display: flex; flex-direction: column; justify-content: center; width: 100%; }
        
        .p-name { font-weight: bold; font-size: 1.1em; color: var(--primary); display: block; }
        .goal-text { display: block; font-size: 1.3em; color: #2980b9; font-weight: 800; margin-top: 3px; white-space: normal; line-height: 1.1; }
        .p-sub { font-size: 0.85em; color: #666; display: block; margin-top: 2px; font-weight: bold; }

        .input-container { display: flex; align-items: center; flex-shrink: 0; }
        .p-input { width: 80px; text-align: center; font-size: 18px; font-weight: bold; height: 50px; margin: 0; box-sizing: border-box; vertical-align: middle; }
        
        .input-error { border: 2px solid var(--danger) !important; background-color: #fce4e4 !important; }
        #error-msg { color: var(--danger); font-weight: bold; text-align: center; display: none; margin-bottom: 10px; }

        .dealer-badge { display: inline-block; background: #2c3e50; color: white; font-size: 0.7em; padding: 2px 5px; border-radius: 4px; margin-left: 6px; vertical-align: middle; font-weight: bold; text-transform: uppercase; }
        .star-toggle { font-size: 1.5em; color: #ccc; cursor: pointer; margin-right: 10px; line-height: 1; user-select: none; }
        .star-toggle.active { color: var(--gold); text-shadow: 0 1px 2px rgba(0,0,0,0.2); }

        .starter-btn { background: white; border: 2px solid #ccc; padding: 0 5px; border-radius: 8px; cursor: pointer; margin-left: 10px; height: 44px; display: inline-flex; align-items: center; transition: all 0.2s; }
        .starter-btn svg { width: auto; height: 32px; }
        .starter-btn.active { background: #fdebd0; border-color: var(--c-mexicantrain); box-shadow: 0 0 5px var(--c-mexicantrain); }
        
        /* GENERIC BUTTON STYLES */
        .qw-btn-group { display: flex; gap: 6px; margin-right: 12px; align-items: center; }
        .qw-btn { width: 50px; height: 50px; margin: 0; box-sizing: border-box; border: 2px solid #ddd; border-radius: 8px; font-weight: 800; font-size: 0.9em; color: #999; background: white; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; line-height: 1; transition: all 0.2s; vertical-align: middle; }
        .qw-btn.qw-end { width: 60px; font-size: 0.8em; }
        .qw-btn span { font-size: 0.7em; font-weight: normal; margin-top: 2px; }
        
        /* PEEK BUTTONS */
        .btn-peek { background: #ecf0f1; color: #7f8c8d; border: 2px dashed #bdc3c7; border-radius: 6px; font-weight: bold; cursor: pointer; padding: 8px; width: 100%; text-align: center; user-select: none; font-size: 0.9em; transition: all 0.1s; }
        .btn-peek:active { background: #fff; border-color: var(--primary); color: var(--primary); transform: scale(0.98); }
        
        /* QWIRKLE */
        .qw-btn.qw-q.active { background: #8e44ad; color: white; border-color: #8e44ad; }
        .qw-btn.qw-qq.active { background: #e67e22; color: white; border-color: #e67e22; }
        .qw-btn.qw-end.active { background: #2c3e50; color: white; border-color: #2c3e50; }
        
        /* HEARTS MOON */
        .qw-btn.qw-moon { border-color: #8e44ad; color: #8e44ad; }
        .qw-btn.qw-moon.active { background: #8e44ad; color: white; box-shadow: 0 2px 5px rgba(142, 68, 173, 0.4); }

        .badge-q { background: #8e44ad; color: white; font-size: 0.7em; padding: 1px 4px; border-radius: 4px; margin-right: 2px; }
        .badge-qq { background: #e67e22; color: white; font-size: 0.7em; padding: 1px 4px; border-radius: 4px; margin-right: 2px; }
        .badge-end { background: #2c3e50; color: white; font-size: 0.7em; padding: 1px 4px; border-radius: 4px; }
        
        .table-sub { display: block; font-size: 0.75em; color: #666; margin-top: 2px; line-height: 1; }
        
        /* LEADERBOARD */
        .lb-section { margin-bottom: 20px; }
        .lb-title { font-size: 1.1em; color: var(--primary); border-bottom: 2px solid var(--accent); margin-bottom: 10px; padding-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .btn-lb-reset { background: transparent; color: #999; border: 1px solid #ddd; font-size: 0.7em; padding: 4px 8px; width: auto; margin: 0; border-radius: 4px; }
        .lb-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        .lb-table th { background: #f4f4f4; color: #555; text-align: center; padding: 6px; font-size: 0.8em; border-bottom: 2px solid #ddd; }
        .lb-table td { padding: 8px; border-bottom: 1px solid #eee; text-align: center; }
        .lb-table td:first-child { text-align: left; font-weight: bold; color: var(--primary); }
        .lb-win-badge { background: var(--accent); color: white; padding: 2px 6px; border-radius: 10px; font-weight: bold; font-size: 0.9em; }

        .custom-name-box { display: none; margin-top: 5px; } 
        .team-label { font-size: 1.2em; color: var(--accent); margin-bottom: 10px; display: block; }
        #game-over-banner { background: #f9f9f9; padding: 20px; text-align: center; border-radius: 10px; border: 2px solid var(--primary); margin-bottom: 20px; }
        .winner-text { font-size: 1.5em; font-weight: bold; color: var(--accent); display: block; margin-top: 10px; }

        /* OLD HELL */
        .oh-trump-row { display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; }
        .oh-trump-btn { width: 60px; height: 60px; border: 2px solid #ddd; border-radius: 10px; background: white; font-size: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .oh-trump-btn.selected { border-color: var(--primary); background: #e8f4fd; transform: scale(1.1); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .oh-toggle-btn { border: none; border-radius: 8px; font-weight: bold; color: white; width: 100px; height: 50px; font-size: 16px; cursor: pointer; transition: background 0.2s; }
        .oh-toggle-btn.made { background: #27ae60; }
        .oh-toggle-btn.failed { background: #c0392b; }
        .oh-bid-disp { font-size: 1.2em; font-weight: bold; color: #555; margin-right: 15px; white-space: nowrap; }

        /* Split Cell (Used by Old Hell & Spades) */
        .oh-cell { display: flex; justify-content: space-between; align-items: center; width: 100%; height: 100%; font-weight: bold; }
        .oh-made { background-color: #d4edda !important; color: #155724; }
        .oh-missed { background-color: #f8d7da !important; color: #721c24; }
        
        /* Spades Stacked Cell */
        .spades-cell { display: flex; justify-content: space-between; align-items: center; width:100%; height: 100%; }
        .spades-details { display: flex; flex-direction: column; align-items: flex-start; font-size: 0.75em; color: #666; line-height: 1.3; margin-right: 4px; text-align: left; }
        .spades-score { font-weight: bold; font-size: 1.1em; color: #000; }
        .s-label { white-space: nowrap; }

        /* Footer alignment for games with split cells */
        .game-oldhell tfoot td, .game-spades tfoot td { text-align: right; padding-right: 10px; }
        .game-oldhell th:not(:first-child):not(:nth-child(2)),
        .game-spades th:not(:first-child) { text-align: right; padding-right: 10px; }

        /* SPADES SPECIFIC */
        .spades-bn-btn {
            background: transparent; color: #999; border: 2px solid #ddd;
            border-radius: 8px; height: 50px; padding: 0 10px; 
            font-weight: bold; font-size: 0.8em; cursor: pointer; 
            margin: 0 10px 0 0; transition: all 0.2s; box-sizing: border-box;
            vertical-align: middle;
        }
        .spades-bn-btn.active {
            background: #2c3e50; color: white; border-color: #2c3e50; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body onload="initApp()">

<div class="card" id="setup-screen">
    <h2 style="text-align:center">üé≤ Game Scorer</h2>
    <button id="restore-btn" class="btn-restore" style="display:none;" onclick="restoreGame()">‚ö†Ô∏è Resume Last Game</button>
    <button class="btn-info" onclick="showLeaderboard()">üèÜ Leaderboard</button>

    <div class="setup-group">
        <label>Select Game</label>
        <select id="game-select" onchange="updateSetupUI()">
            </select>
    </div>
    <div class="setup-group">
        <label>Number of Players</label>
        <input type="number" id="player-count" inputmode="decimal" value="4" onfocus="this.select()" oninput="updateSetupUI()">
    </div>
    <div id="target-option" class="setup-group" style="display:none;">
        <label>Target Score</label>
        <input type="number" id="target-score" inputmode="decimal">
    </div>
    <div id="team-option" class="setup-group" style="display:none;">
        <label><input type="checkbox" id="use-teams"> Play in Teams?</label>
    </div>
    <div id="random-option" class="setup-group" style="display:none;">
        <label><input type="checkbox" id="randomize-goals"> üîÄ Randomize Goals?</label>
    </div>
    <button class="btn-game-action" onclick="showNames()">Next</button>
</div>

<div class="card" id="name-screen" style="display:none;">
    <h2 style="text-align:center">Who is Playing?</h2>
    <div id="name-inputs"></div>
    <button class="btn-game-action" onclick="startGame()">Start Game</button>
    <button class="btn-outline" onclick="location.reload()">Back</button>
</div>

<div class="card" id="game-screen" style="display:none;">
    <div class="game-header">
        <div class="round-title" id="round-label"></div>
        <div class="hero-display" id="hero-content"></div>
    </div>
    
    <div id="game-over-banner" style="display:none;">
        <h2>üèÜ Game Over!</h2>
        <span class="winner-text" id="winner-display"></span>
    </div>
    
    <div id="input-area"></div>
    <div id="error-msg"></div>

    <button id="action-btn" class="btn-game-action" onclick="submitRound()">Submit</button>

    <div style="overflow-x:auto">
        <table id="score-table">
            <thead><tr id="table-head"></tr></thead>
            <tbody id="table-body"></tbody>
            <tfoot><tr id="table-foot" style="background:#eee; font-weight:bold"></tr></tfoot>
        </table>
    </div>
    
    <div id="controls-area">
        <button id="undo-btn" class="btn-undo" style="display:none" onclick="undoRound()">‚Ü© Undo</button>
        <button id="exit-btn" class="btn-exit" onclick="confirmExit()">End Game & Exit</button>
    </div>
</div>

<div class="card" id="leaderboard-screen" style="display:none;">
    <h2 style="text-align:center">üèÜ Hall of Fame</h2>
    <div id="lb-content"></div>
    
    <button class="btn-game-action" onclick="closeLeaderboard()">Main Menu</button>
    <button class="btn-outline" onclick="clearLeaderboard()">Reset All</button>

    <div style="background:#e8f4fd; padding:15px; border-radius:10px; margin-top:20px; text-align:center; border:2px solid #3498db;">
        <h3 style="margin-top:0; color:#2c3e50;">‚òÅÔ∏è Cloud Backup</h3>
        <p style="font-size:0.85em; color:#555;">Save your history to a file so you can move it to another device.</p>
        <button class="btn-game-action" style="background:#27ae60; margin-bottom:10px;" onclick="exportData()">‚¨áÔ∏è Save to File</button>
        <button class="btn-outline" style="background:white; border-color:#2980b9; color:#2980b9;" onclick="triggerImport()">‚¨ÜÔ∏è Load from File</button>
        <input type="file" id="import-file" style="display:none" onchange="importData(this)">
    </div>
</div>

<script>
/** * CONFIGURATION */
const GAMES = {
    shanghai: {
        name: "Shang-Hi", color: "#27ae60",
        type: "low_score", 
        phases: ["score"], 
        rounds: [
            "2 Sets of 3", "1 Set of 3, 1 Run of 4", "2 Runs of 4", "3 Sets of 3",
            "1 Set of 3, 1 Run of 7", "2 Sets of 3, 1 Run of 5", "3 Runs of 4",
            "1 Set of 3, 1 Run of 10", "3 Sets of 3, 1 Run of 5", "3 Runs of 5"
        ],
        hasTeams: true, hasRandomize: true, hasDealer: true, hasStars: true
    },
    mexicantrain: {
        name: "Mexican Train", color: "#d35400",
        type: "low_score",
        phases: ["score"],
        rounds: 13, 
        hasStarter: true, 
        hasTeams: false
    },
    oldhell: {
        name: "Old Hell", color: "#8e44ad",
        type: "high_score",
        phases: ["bid", "score"], 
        handSize: 52, 
        hasDealer: true, hasTeams: false
    },
    spades: {
        name: "Spades", color: "#2c3e50",
        type: "target_score", 
        target: 500,
        phases: ["bid", "score"],
        hasDealer: true, hasTeams: true,
        hasBlindNil: true
    },
    hearts: {
        name: "Hearts", color: "#c0392b",
        type: "low_score",
        target: 100, 
        maxPlayers: 6, 
        phases: ["score"],
        validation: "sum_26", 
        hasDealer: true, 
        hasTeams: false,
        helpers: [
            { id: 'moon', label: 'Moon', val: 0, text: 'üåô' }
        ]
    },
    rummikub: {
        name: "Rummikub", color: "#2980b9",
        type: "high_score", 
        phases: ["score"],
        rounds: 99, 
        hasDealer: false, hasTeams: false
    },
    triominos: {
        name: "Triominos", color: "#f39c12",
        type: "low_score", 
        phases: ["score"],
        rounds: 99,
        hasDealer: false, hasTeams: false
    },
    qwirkle: {
        name: "Qwirkle", color: "#e74c3c",
        type: "high_score",
        phases: ["score"],
        rounds: 99,
        hasDealer: false, hasTeams: false,
        helpers: [
            { id: 'q', label: 'Q', val: 6, text: '+6' },
            { id: 'qq', label: 'QQ', val: 12, text: '+12' },
            { id: 'end', label: 'Finish', val: 6, isEnd: true, text: '+6' }
        ]
    }
};

const COMMON_NAMES = ["Angie", "Daren", "Derek", "Dylan", "Lina", "Nick", "Quinn"];
const DOMINO_COLORS = ['none','#1E90FF','#2ECC71','#E74C3C','#A0522D','#F1C40F','#16A085','#9B59B6','#00BFFF','#FF00FF','#FF8C00','#333333','#95A5A6'];

// ============================================
//   CLASS ARCHITECTURE
// ============================================

class GameBase {
    constructor(config, players, settings) {
        this.conf = config;
        this.players = players; 
        this.settings = settings; 
        
        this.round = 1;
        this.history = [];
        this.isGameOver = false;
        this.dealCount = 0;
        this.phase = 'score'; 
        
        this.modifiers = [];
        this.currentStars = new Array(players.length).fill(false);
        this.tempInput = [];
    }

    getDealerIdx() {
        if (!this.conf.hasDealer) return -1;
        if (this.settings.useTeams) {
            let numTeams = this.players.length / 2;
            let teamIndex = this.dealCount % numTeams;
            let memberIndex = Math.floor(this.dealCount / numTeams) % 2;
            return (teamIndex * 2) + memberIndex;
        }
        return this.dealCount % this.players.length;
    }

    getHeroContent() {
        return `<span class="hero-display">${this.conf.name}<br>Round ${this.round}</span>`;
    }
    
    getRoundDescription(playerIdx, roundIdx) { return ""; } 

    // BASE VALIDATION: Check RAW inputs for content
    validateInput(rawInputs) {
        let hasContent = false;
        rawInputs.forEach(val => { if (val !== '') hasContent = true; });
        if (!hasContent) return { valid: false, msg: "Enter at least one score." };
        return { valid: true };
    }

    createSnapshot() {
        return this.players.map(p => ({...p})); 
    }

    submitRound(rawInputs, modifiers = []) {
        const validation = this.validateInput(rawInputs);
        if (!validation.valid) return validation;

        const inputs = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        const snapshot = this.createSnapshot(); 

        const scores = inputs.map((val, i) => {
            let s = val;
            if (modifiers[i]) {
                modifiers[i].forEach(modId => {
                    let def = this.conf.helpers.find(h => h.id === modId);
                    if (def) s += def.val;
                });
            }
            return s;
        });

        this.players.forEach((p, i) => p.total += scores[i]);

        this.history.push({
            label: this.round,
            scores: scores,
            dealerIdx: this.getDealerIdx(),
            meta: { raw: rawInputs, mods: modifiers },
            starFlags: [...this.currentStars],
            snapshot: snapshot 
        });

        this.advanceRound();
        this.modifiers = [];
        this.currentStars.fill(false);
        this.tempInput = [];
        return { valid: true };
    }

    advanceRound() {
        this.dealCount++;
        this.round++;
        if (this.settings.targetScore > 0) {
            const scores = this.players.map(p => p.total);
            const check = (this.conf.type === 'low_score') ? Math.min(...scores) : Math.max(...scores);
            if (check >= this.settings.targetScore) this.isGameOver = true;
        }
    }

    undo() {
        if (!this.history.length) return null;
        const last = this.history.pop();
        
        this.isGameOver = false;
        this.round--;
        this.dealCount--;

        if (last.snapshot) {
            this.players = last.snapshot;
        } else {
            this.players.forEach((p, i) => p.total -= last.scores[i]);
        }
        
        if (last.meta && last.meta.raw) this.tempInput = last.meta.raw;
        if (last.meta && last.meta.mods) this.modifiers = last.meta.mods;
        if (last.starFlags) this.currentStars = last.starFlags;
        
        return last;
    }
}

// ============================================
//   GAME IMPLEMENTATIONS
// ============================================

class SimpleScoreGame extends GameBase {
    // For Qwirkle
    constructor(config, players, settings) {
        super(config, players, settings);
    }
}

class TriominosGame extends GameBase {
    // For Triominos (Golf/Penalty variant)
    constructor(config, players, settings) {
        super(config, players, settings);
    }
    
    validateInput(rawInputs) {
        // Must have exactly one zero (the winner who went out)
        const inputs = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        let zeros = inputs.filter(v => v === 0).length;
        
        if (zeros === 0) return { valid: false, msg: "Someone must have 0 (The Winner)." };
        if (zeros > 1) return { valid: false, msg: "Only one person can have 0." };
        
        return super.validateInput(rawInputs);
    }
}

class RummikubGame extends GameBase {
    constructor(config, players, settings) {
        super(config, players, settings);
    }
    
    validateInput(rawInputs) {
        // One winner must have 0
        const inputs = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        let zeros = inputs.filter(v => v === 0).length;
        if (zeros === 0) return { valid: false, msg: "Someone must have 0 (Winner)." };
        if (zeros > 1) return { valid: false, msg: "Only one person can have 0." };
        
        return super.validateInput(rawInputs);
    }
    
    // Override submit for special math (Winner gets sum of others)
    submitRound(rawInputs, modifiers = []) {
        const validation = this.validateInput(rawInputs);
        if (!validation.valid) return validation;
        
        const inputs = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        let winnerIdx = inputs.indexOf(0);
        let totalPot = inputs.reduce((a,b)=>a+b, 0); 
        
        // Re-map scores: Winner gets pot, losers get negative
        const finalScores = inputs.map((val, i) => {
            if (i === winnerIdx) return totalPot;
            return -val;
        });
        
        const snapshot = this.createSnapshot();
        this.players.forEach((p, i) => p.total += finalScores[i]);
        
        this.history.push({
            label: this.round,
            scores: finalScores,
            dealerIdx: this.getDealerIdx(),
            meta: { raw: rawInputs, mods: modifiers },
            starFlags: [...this.currentStars],
            snapshot: snapshot 
        });
        
        this.advanceRound();
        this.modifiers = [];
        this.currentStars.fill(false);
        this.tempInput = [];
        return { valid: true };
    }
}

class ShanghaiGame extends GameBase {
    constructor(config, players, settings) {
        super(config, players, settings);
        this.contracts = [...config.rounds];
        this.randomMap = null;
        if (settings.randomize) {
            if (settings.useTeams) {
                // Generate team-based random goals
                this.randomMap = new Array(players.length);
                let teamCount = players.length / 2;
                for(let t=0; t<teamCount; t++) {
                    // Create one random sequence per team
                    let goals = [...config.rounds].sort(() => 0.5 - Math.random());
                    this.randomMap[t*2] = goals;
                    this.randomMap[t*2+1] = goals;
                }
            } else {
                // Individual random goals
                this.randomMap = players.map(() => [...config.rounds].sort(() => 0.5 - Math.random()));
            }
        }
    }
    getHeroContent() {
        if (this.randomMap) {
            return this.settings.useTeams ? `(INDIVIDUAL TEAM GOALS)` : `(INDIVIDUAL GOALS)`;
        }
        const txt = this.contracts[this.round - 1] || "Finish";
        return `<span class="hero-display">${txt}</span>`;
    }
    getRoundDescription(playerIdx, roundIdx) {
        if (this.randomMap) return this.randomMap[playerIdx][roundIdx];
        if (playerIdx === 0) return this.contracts[roundIdx];
        return "";
    }
    validateInput(rawInputs) {
        let validNums = [];
        let hasContent = false;
        for (let i = 0; i < rawInputs.length; i++) {
            if (rawInputs[i] !== '') hasContent = true;
            let val = parseInt(rawInputs[i]);
            if (isNaN(val)) val = 0;
            if (val % 5 !== 0) return { valid: false, msg: `Player ${i+1}: Score must be multiple of 5` };
            validNums.push(val);
        }
        if (!hasContent) return { valid: false, msg: "Enter scores." };
        
        if (this.settings.useTeams) {
            let winningTeams = 0;
            let partialZero = false;
            for (let i = 0; i < this.players.length; i += 2) {
                let s1 = validNums[i];
                let s2 = validNums[i+1];
                if (s1 === 0 && s2 === 0) winningTeams++;
                else if (s1 === 0 || s2 === 0) partialZero = true;
            }
            if (partialZero) return { valid: false, msg: "Team Rule: Both partners must have 0 to win." };
            if (winningTeams === 0) return { valid: false, msg: "One team must have 0 (both players)." };
            if (winningTeams > 1) return { valid: false, msg: "Only one team can have 0." };
        } else {
            let zeros = validNums.filter(v => v === 0).length;
            if (zeros === 0) return { valid: false, msg: "Someone must have 0." };
            if (zeros > 1) return { valid: false, msg: "Only one person can have 0." };
        }
        return { valid: true };
    }
    advanceRound() {
        super.advanceRound();
        if (this.round > 10) this.isGameOver = true;
    }
}

class SpadesGame extends GameBase {
    constructor(config, players, settings) {
        super(config, players, settings);
        this.phase = 'bid';
        this.tempBlindNil = new Array(players.length).fill(false);
    }

    getHeroContent() {
        return (this.phase === 'bid') ? `<span class="hero-display">BID</span>` : `<span class="hero-display">TRICKS</span>`;
    }

    toggleBlindNil(idx) {
        this.tempBlindNil[idx] = !this.tempBlindNil[idx];
    }

    submitRound(rawInputs) {
        if (this.phase === 'bid') return this.handleBid(rawInputs);
        return this.handleScore(rawInputs);
    }

    handleBid(rawInputs) {
        const bids = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        this.players.forEach((p, i) => {
            p.bid = bids[i];
            p.isBlindNil = this.tempBlindNil[i];
        });

        let displayBids = this.players.map(p => p.isBlindNil ? "BN" : (p.bid===0 ? "Nil" : p.bid));
        
        this.history.push({
            label: this.round,
            scores: displayBids,
            isBid: true,
            dealerIdx: this.getDealerIdx(),
            snapshot: this.createSnapshot()
        });

        this.phase = 'score';
        this.tempInput = [];
        this.tempBlindNil.fill(false);
        return { valid: true };
    }

    handleScore(rawInputs) {
        // Pop the bid history so we can merge
        const bidHistory = this.history.pop();
        
        let hasContent = false;
        let trickInputs = rawInputs.map(v => {
            let n = parseInt(v);
            if(!isNaN(n)) hasContent = true;
            return isNaN(n) ? 0 : n;
        });

        if (!hasContent) {
            this.history.push(bidHistory); // Put bids back if validation fails
            return { valid: false, msg: "Please enter tricks." };
        }
        let totalTricks = trickInputs.reduce((a,b)=>a+b,0);
        if(totalTricks !== 13) {
            this.history.push(bidHistory); 
            return { valid: false, msg: `Total tricks must be 13 (Counted: ${totalTricks})` };
        }

        const snapshot = this.createSnapshot(); 
        let roundScores = [];

        if (this.settings.useTeams) {
            let teamCount = this.players.length / 2;
            let teamScores = new Array(this.players.length).fill(0);
            
            for(let t=0; t<teamCount; t++) {
                let p1Idx = t*2; let p2Idx = t*2+1;
                let p1 = this.players[p1Idx]; let p2 = this.players[p2Idx];
                let t1 = trickInputs[p1Idx]; let t2 = trickInputs[p2Idx];
                
                let teamScore = 0;
                let teamBags = 0;
                let combinedTricks = t1 + t2;
                let requiredTricks = 0;

                const handleNil = (p, tricks) => {
                    if (p.isBlindNil) return (tricks === 0) ? 200 : -200;
                    if (p.bid === 0) return (tricks === 0) ? 100 : -100;
                    requiredTricks += p.bid;
                    return 0;
                };

                teamScore += handleNil(p1, t1);
                teamScore += handleNil(p2, t2);

                if (requiredTricks > 0) {
                    if (combinedTricks >= requiredTricks) {
                        teamScore += (requiredTricks * 10);
                        let bags = combinedTricks - requiredTricks;
                        teamScore += bags;
                        teamBags += bags;
                    } else {
                        teamScore -= (requiredTricks * 10);
                    }
                }

                p1.bags = (p1.bags || 0) + teamBags;
                if (p1.bags >= 10) {
                    teamScore -= 100;
                    p1.bags -= 10;
                }

                teamScores[p1Idx] = teamScore;
                teamScores[p2Idx] = teamScore;
                p1.total += teamScore;
                p2.total += teamScore;
            }
            roundScores = teamScores;
        } else {
            roundScores = trickInputs.map((tricks, i) => {
                let p = this.players[i];
                let s = 0;
                if (p.isBlindNil) { s = (tricks === 0) ? 200 : -200; }
                else if (p.bid === 0) { s = (tricks === 0) ? 100 : -100; }
                else {
                    if (tricks >= p.bid) {
                        s = (p.bid * 10) + (tricks - p.bid);
                        p.bags = (p.bags || 0) + (tricks - p.bid);
                    } else {
                        s = -(p.bid * 10);
                    }
                }
                if (p.bags >= 10) { s -= 100; p.bags -= 10; }
                p.total += s;
                return s;
            });
        }

        this.history.push({
            label: this.round,
            scores: roundScores,
            bids: bidHistory.scores, // Store the display string of bids
            tricks: trickInputs, // Store raw tricks for detail display
            dealerIdx: this.getDealerIdx(),
            snapshot: snapshot,
            isComplete: true, // Mark for renderTable
            meta: { raw: rawInputs }
        });

        this.dealCount++;
        this.round++;
        this.phase = 'bid';
        this.tempInput = [];
        
        let top = Math.max(...this.players.map(p=>p.total));
        if (top >= this.settings.targetScore) this.isGameOver = true;
        
        return { valid: true };
    }
    
    undo() {
        let last = super.undo();
        if (last.isBid) {
            this.phase = 'bid';
            this.tempInput = last.scores;
            this.tempBlindNil = this.players.map(p => p.isBlindNil);
            // Manually fix counts because handleBid doesn't increment
            this.dealCount++;
            this.round++;
        } else if (last.isComplete) {
            // Restore the bid phase
            this.history.push({
                label: last.label,
                scores: last.bids, 
                isBid: true,
                dealerIdx: last.dealerIdx,
                snapshot: last.snapshot
            });
            this.phase = 'score';
            this.tempInput = last.meta.raw;
        }
        return last;
    }
}

class OldHellGame extends GameBase {
    constructor(config, players, settings) {
        super(config, players, settings);
        this.handSize = Math.floor(52 / players.length);
        this.phase = 'bid';
        this.currentTrump = '';
    }

    getHeroContent() {
        if (this.phase === 'bid') return `<span class="hero-display">BID<br><span style="font-size:0.6em">${this.handSize} Cards</span></span>`;
        return `<span class="hero-display">SCORE<br><span style="font-size:0.6em">${this.handSize} Cards</span></span>`;
    }

    setTrump(t) {
        this.currentTrump = t;
    }

    submitRound(rawInputs) {
        if (this.phase === 'bid') return this.handleBid(rawInputs);
        return this.handleScore(rawInputs);
    }

    handleBid(rawInputs) {
        if (!this.currentTrump) return { valid: false, msg: "Select a Trump suit." };
        const bids = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        const totalBids = bids.reduce((a,b)=>a+b, 0);
        if (totalBids === this.handSize) {
             return { valid: false, msg: `Screw the Dealer: Total bids (${totalBids}) cannot equal card count (${this.handSize}).` };
        }
        this.players.forEach((p, i) => p.bid = bids[i]);
        
        this.history.push({
            label: this.handSize,
            scores: bids,
            isBid: true,
            dealerIdx: this.getDealerIdx(),
            trump: this.currentTrump,
            snapshot: this.createSnapshot()
        });
        this.phase = 'score';
        this.tempInput = [];
        return { valid: true };
    }

    handleScore(rawInputs) {
        // Pop the "Bid" history item so we can merge it into a single "Complete" row
        const bidHistory = this.history.pop();

        const snapshot = this.createSnapshot();
        const scores = this.players.map((p, i) => {
            const made = rawInputs[i] === 'true';
            return made ? (10 + p.bid) : 0;
        });
        
        const allMade = rawInputs.every(v => v === 'true');
        const sumBids = this.players.reduce((a,p) => a + p.bid, 0);
        if (allMade && sumBids !== this.handSize) {
            // Restore Bid history if we fail validation
            this.history.push(bidHistory);
             return { valid: false, msg: "Impossible! Total bids didn't match card count, so someone must have missed." };
        }

        this.players.forEach((p, i) => p.total += scores[i]);

        this.history.push({
            label: this.handSize,
            bids: this.players.map(p => p.bid), // Save bids explicitly
            scores: scores,
            isComplete: true, // Marker for renderer to show dual-view
            dealerIdx: this.getDealerIdx(),
            trump: this.currentTrump,
            meta: { raw: rawInputs },
            snapshot: snapshot
        });

        this.dealCount++;
        this.handSize--;
        this.phase = 'bid';
        this.currentTrump = '';
        this.tempInput = [];
        if (this.handSize < 1) this.isGameOver = true;
        return { valid: true };
    }
    
    undo() {
        let last = super.undo(); // Decrements dealCount, round
        
        if (last.isBid) {
            // Undoing a Bid
            this.phase = 'bid';
            this.currentTrump = last.trump;
            this.tempInput = last.scores;
            // FIX: handleBid didn't increment dealCount, but super.undo() decremented it.
            this.dealCount++; 
            this.round++;
        } else if (last.isComplete) {
            // Undoing a Score
            this.history.push({
                label: last.label,
                scores: last.bids, 
                isBid: true,
                dealerIdx: last.dealerIdx,
                trump: last.trump,
                snapshot: last.snapshot
            });
            
            this.phase = 'score';
            this.handSize++; 
            this.currentTrump = last.trump;
            this.tempInput = last.meta.raw;
        }
        return last;
    }
}

class HeartsGame extends GameBase {
    constructor(config, players, settings) {
        super(config, players, settings);
    }
    getHeroContent() {
        let r = (this.round - 1); 
        let seq = [];
        const playerCount = this.players.length;
        if (playerCount === 3) seq = ["Left", "Right", "Hold"];
        else if (playerCount === 4) seq = ["Left", "Right", "Across", "Hold"];
        else if (playerCount === 5) seq = ["Left", "Right", "2 Left", "2 Right", "Hold"];
        else if (playerCount === 6) seq = ["Left", "Right", "2 Left", "2 Right", "3 Left", "3 Right"];
        else seq = ["Left", "Right", "Across", "Hold"]; 
        let msg = "Pass " + seq[r % seq.length];
        return `<span class="hero-display" style="font-size:1.2em">${msg}</span>`;
    }
    getRoundDescription(pIdx, rIdx) {
        let r = rIdx; 
        let seq = [];
        const playerCount = this.players.length;
        if (playerCount === 3) seq = ["Left", "Right", "Hold"];
        else if (playerCount === 4) seq = ["Left", "Right", "Across", "Hold"];
        else seq = ["Left", "Right", "Across", "Hold"]; 
        return seq[r % seq.length];
    }
    validateInput(rawInputs) {
        let hasContent = false;
        rawInputs.forEach(val => { if (val !== '') hasContent = true; });
        if (!hasContent) return { valid: false, msg: "Enter at least one score." };
        
        const inputs = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        let sum = inputs.reduce((a,b) => a + (isNaN(b)?0:b), 0);
        let moonSum = 26 * (this.players.length - 1);
        
        if (sum !== 26 && sum !== moonSum) {
            return { valid: false, msg: `Total must be 26 (or ${moonSum} for Moon). You have ${sum}.` };
        }
        return { valid: true };
    }
}

class MexicanTrainGame extends GameBase {
    constructor(config, players, settings) {
        super(config, players, settings);
        this.manualStarter = -1;
    }
    
    getHeroContent() {
        let val = 13 - this.round;
        if (val < 0) val = 0;
        return getDominoSvg(val, 60) + getDominoSvg(val, 60);
    }
    getRoundDescription(pIdx, rIdx) {
        let val = 13 - (rIdx + 1);
        if (val < 0) return "";
        return getDominoSvg(val, 20) + getDominoSvg(val, 20);
    }
    getDealerIdx() { return this.manualStarter; }
    setStarter(idx) { this.manualStarter = idx; }
    
    validateInput(rawInputs) {
        let base = super.validateInput(rawInputs);
        if (!base.valid) return base;
        
        if (this.manualStarter === -1) return { valid: false, msg: "Who started the round? Tap a domino." };
        
        // Strict Zero Check (Winner)
        const inputs = rawInputs.map(v => (v === '' ? 0 : parseInt(v)));
        let zeroCount = inputs.filter(v => v === 0).length;
        
        if (zeroCount === 0) return { valid: false, msg: "Someone must have 0 (The Winner)." };
        if (zeroCount > 1) return { valid: false, msg: "Only one person can have 0." };
        
        return { valid: true };
    }
    
    advanceRound() {
        this.dealCount++;
        this.round++;
        this.manualStarter = -1;
        if (this.round > 13) this.isGameOver = true;
    }
    undo() {
        let last = super.undo();
        if (last) this.manualStarter = last.dealerIdx; 
        return last;
    }
}


// ============================================
//   GLOBAL STATE
// ============================================

let state = {
    gameKey: 'shanghai',
    currentGame: null
};

function initApp() {
    resetTheme(); 
    const sel = document.getElementById('game-select');
    for (let key in GAMES) {
        let opt = document.createElement('option');
        opt.value = key;
        opt.innerText = GAMES[key].name;
        sel.appendChild(opt);
    }
    checkRestore();
    updateSetupUI();
}

function resetTheme() {
    document.documentElement.style.removeProperty('--primary');
    document.documentElement.style.removeProperty('--accent');
}

function updateSetupUI() {
    const key = document.getElementById('game-select').value;
    let count = parseInt(document.getElementById('player-count').value) || 0;
    const conf = GAMES[key];
    
    if(conf.maxPlayers && count > conf.maxPlayers) {
        count = conf.maxPlayers;
        document.getElementById('player-count').value = count;
    }
    
    const teamDiv = document.getElementById('team-option');
    const teamLabel = teamDiv.querySelector('label');
    const teamCheck = document.getElementById('use-teams');

    if (conf.hasTeams) {
        teamDiv.style.display = 'block';
        if (count % 2 !== 0) {
            teamCheck.disabled = true;
            teamCheck.checked = false;
            teamLabel.style.color = '#bbb';
            teamLabel.childNodes[1].textContent = " Teams Unavailable (Need Even #)";
        } else {
            teamCheck.disabled = false;
            teamLabel.style.color = 'var(--primary)';
            teamLabel.childNodes[1].textContent = " Play in Teams?";
        }
    } else {
        teamDiv.style.display = 'none';
        teamCheck.checked = false;
    }

    document.getElementById('random-option').style.display = conf.hasRandomize ? 'block' : 'none';
    
    const targetDiv = document.getElementById('target-option');
    if (conf.type === 'target_score' || key === 'hearts') {
        targetDiv.style.display = 'block';
        document.getElementById('target-score').value = conf.target;
    } else {
        targetDiv.style.display = 'none';
    }
}

function showNames() {
    state.gameKey = document.getElementById('game-select').value;
    const count = parseInt(document.getElementById('player-count').value);
    const useTeams = document.getElementById('use-teams').checked;
    
    document.getElementById('setup-screen').style.display = 'none';
    document.getElementById('name-screen').style.display = 'block';
    
    const container = document.getElementById('name-inputs');
    container.innerHTML = '';
    const numUnits = useTeams ? count/2 : count;
    
    for(let i=1; i<=numUnits; i++) {
        let html = `<div class="setup-group">`;
        if (useTeams) {
            html += `<span class="team-label">Team ${i}</span>
                     <label>Member 1</label>${nameDropdown(i+'-a')}
                     <label>Member 2</label>${nameDropdown(i+'-b')}`;
        } else {
            html += `<label>Player ${i}</label>${nameDropdown(i)}`;
        }
        html += `</div>`;
        container.innerHTML += html;
    }
    updateNameDropdowns();
}

function nameDropdown(id) {
    let opts = COMMON_NAMES.map(n => `<option value="${n}">${n}</option>`).join('');
    return `<select id="n-${id}" class="name-selector" onchange="handleNameChange(this, 'c-${id}')">
        <option value="">-- Select --</option>${opts}<option value="CUSTOM">Type Name...</option>
    </select>
    <input type="text" id="c-${id}" class="custom-name-box" placeholder="Name">`;
}

function handleNameChange(sel, inputId) {
    const input = document.getElementById(inputId);
    input.style.display = (sel.value === 'CUSTOM') ? 'block' : 'none';
    if(sel.value === 'CUSTOM') input.focus();
    updateNameDropdowns();
}

function updateNameDropdowns() {
    const selects = document.querySelectorAll('.name-selector');
    const taken = Array.from(selects).map(s => s.value).filter(v => v !== "" && v !== "CUSTOM");
    selects.forEach(dropdown => {
        const myValue = dropdown.value;
        dropdown.querySelectorAll('option').forEach(opt => {
            if (opt.value === "" || opt.value === "CUSTOM") return;
            if (taken.includes(opt.value) && opt.value !== myValue) {
                opt.disabled = true; opt.innerText = opt.value + " (Taken)";
            } else {
                opt.disabled = false; opt.innerText = opt.value;
            }
        });
    });
}

function startGame() {
    const conf = GAMES[state.gameKey];
    const count = parseInt(document.getElementById('player-count').value);
    const useTeams = document.getElementById('use-teams').checked;
    const randomize = document.getElementById('randomize-goals').checked;
    const target = parseInt(document.getElementById('target-score').value) || conf.target || 0;
    
    let players = [];
    for(let i=1; i<=count; i++) {
        let name;
        if(useTeams) {
            let teamNum = Math.ceil(i/2);
            let suffix = (i%2 !== 0) ? 'a' : 'b';
            name = getNameVal(`${teamNum}-${suffix}`);
        } else {
            name = getNameVal(i);
        }
        players.push({ name: name, total: 0, bags: 0, bid: 0, isBlindNil: false });
    }

    if (state.gameKey === 'shanghai') {
        state.currentGame = new ShanghaiGame(conf, players, { useTeams, randomize });
    } 
    else if (state.gameKey === 'spades') {
        state.currentGame = new SpadesGame(conf, players, { useTeams, targetScore: target });
    }
    else if (state.gameKey === 'oldhell') {
        state.currentGame = new OldHellGame(conf, players, { useTeams: state.useTeams });
    }
    else if (state.gameKey === 'hearts') {
        state.currentGame = new HeartsGame(conf, players, { targetScore: target });
    }
    else if (state.gameKey === 'mexicantrain') {
        state.currentGame = new MexicanTrainGame(conf, players, {});
    }
    else if (state.gameKey === 'rummikub') {
        state.currentGame = new RummikubGame(conf, players, {});
    }
    else if (state.gameKey === 'triominos') {
        state.currentGame = new TriominosGame(conf, players, {});
    }
    else {
        state.currentGame = new SimpleScoreGame(conf, players, {});
    }
    
    document.body.className = `game-${state.gameKey}`;
    document.documentElement.style.setProperty('--primary', conf.color);
    document.documentElement.style.setProperty('--accent', conf.color);
    
    document.getElementById('name-screen').style.display = 'none';
    document.getElementById('game-screen').style.display = 'block';
    
    if('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(()=>{});
    
    saveState();
    renderGame();
}

function getNameVal(id) {
    let el = document.getElementById('n-'+id);
    if (!el) return `P${id}`;
    let v = el.value;
    return (v === 'CUSTOM' || v === '') ? (document.getElementById('c-'+id).value || 'P'+id) : v;
}

function renderGame() {
    if (!state.currentGame) return; 
    const game = state.currentGame;
    const conf = GAMES[state.gameKey];
    
    document.getElementById('error-msg').style.display = 'none';
    
    let isGameOver = game.isGameOver;
    let roundLabel = `${conf.name}: Round ${game.round}`;
    
    if (state.gameKey === 'oldhell') {
        roundLabel = `Old Hell: ${game.handSize} Cards (${game.phase === 'bid' ? 'Bidding' : 'Scoring'})`;
    }
    
    let hero = game.getHeroContent();
    
    if (isGameOver) {
        document.getElementById('input-area').innerHTML = '';
        document.getElementById('action-btn').style.display = 'none';
        document.getElementById('game-over-banner').style.display = 'block';
        
        const totals = game.players.map(p => p.total);
        let best = (conf.type === 'low_score') ? Math.min(...totals) : Math.max(...totals);
        let winners = game.players.filter(p => p.total === best).map(p => p.name);
        document.getElementById('winner-display').innerText = "Winner: " + winners.join(', ');
        
        document.getElementById('exit-btn').innerText = "Finalize & Exit";
        document.getElementById('undo-btn').style.display = 'block'; 
        
        renderTable(); 
        return; 
    }

    document.getElementById('game-over-banner').style.display = 'none';
    document.getElementById('action-btn').style.display = 'block';
    document.getElementById('exit-btn').innerText = "End Game & Exit";
    
    document.getElementById('round-label').innerText = roundLabel;
    document.getElementById('hero-content').innerHTML = hero;
    
    const area = document.getElementById('input-area');
    area.innerHTML = '';
    
    if (state.gameKey === 'oldhell' && game.phase === 'bid') {
        area.innerHTML = renderTrumpSelector();
    }

    if (game.settings.useTeams) {
        let teamCount = game.players.length / 2;
        for(let t=0; t<teamCount; t++) {
            let teamBox = document.createElement('div');
            teamBox.className = 'team-block';
            
            let headerHtml = `<div class="team-block-header">Team ${t+1}</div>`;
            if (state.gameKey === 'shanghai' && game.randomMap) {
                let p1Idx = t*2;
                let goalTxt = game.randomMap[p1Idx][game.round - 1];
                // PEEK BUTTON FOR TEAM GOAL
                headerHtml += `<button class="btn-peek" 
                    onmousedown="startPeek(this, '${goalTxt}')" 
                    onmouseup="endPeek(this)" 
                    ontouchstart="startPeek(this, '${goalTxt}')" 
                    ontouchend="endPeek(this)"
                    data-orig="üëÅÔ∏è Peek Team Goal">üëÅÔ∏è Peek Team Goal</button>`;
            }
            teamBox.innerHTML = headerHtml;
            
            let p1Idx = t*2;
            teamBox.appendChild(createPlayerRow(game.players[p1Idx], p1Idx));
            
            let p2Idx = t*2+1;
            teamBox.appendChild(createPlayerRow(game.players[p2Idx], p2Idx));
            
            area.appendChild(teamBox);
        }
    } else {
        game.players.forEach((p, i) => {
            area.appendChild(createPlayerRow(p, i));
        });
    }
    
    document.getElementById('action-btn').innerText = (game.phase === 'bid') ? "Lock Bids" : "Submit Scores";
    
    let hasHistory = game.history.length;
    document.getElementById('undo-btn').style.display = hasHistory ? 'block' : 'none';
    
    renderTable();
}

function createPlayerRow(p, i) {
    const game = state.currentGame;
    const conf = GAMES[state.gameKey];
    let dealerIdx = game.getDealerIdx();
    
    let row = document.createElement('div');
    row.className = 'input-row';
    
    let starBtn = "";
    if (conf.hasStars) {
        let active = (game.currentStars && game.currentStars[i]) ? "active" : "";
        starBtn = `<span class="star-toggle ${active}" onclick="toggleStar(${i})">‚òÖ</span>`;
    }

    let info = `<div class="input-left-col">
        ${starBtn}
        <div class="input-text-group">
            <div>
                <span class="p-name">${p.name}`;
    
    if (conf.hasDealer && i === dealerIdx) {
        let label = "DEALER";
        if(state.gameKey === 'mexicantrain') label = "STARTER";
        info += `<span class="dealer-badge">${label}</span>`;
    }

    info += `</span></div>`; 

    let sub = "";
    // SHANGHAI PEEK BUTTON (INDIVIDUAL)
    if (state.gameKey === 'shanghai' && game.randomMap && !game.settings.useTeams) {
        let goalTxt = game.randomMap[i][game.round-1];
        sub = `<button class="btn-peek" 
                onmousedown="startPeek(this, '${goalTxt}')" 
                onmouseup="endPeek(this)" 
                ontouchstart="startPeek(this, '${goalTxt}')" 
                ontouchend="endPeek(this)"
                data-orig="üëÅÔ∏è Hold to Peek">üëÅÔ∏è Hold to Peek</button>`;
    } 
    else if (state.gameKey === 'spades' && game.phase === 'score') {
        let bidTxt = (p.isBlindNil) ? "Blind Nil" : (p.bid === 0 ? "Nil" : p.bid);
        let bagsTxt = (p.bags > 0) ? ` (Bags: ${p.bags})` : "";
        sub = `<span class="p-sub">Bid: ${bidTxt}${bagsTxt}</span>`;
    } 
    
    if(sub) info += sub;
    
    info += `</div>`; 
    
    if (conf.hasStarter) {
        let val = 13 - game.round;
        if(val < 0) val = 0;
        
        let manualStarter = game.manualStarter;
        let active = (manualStarter === i) ? 'active' : '';
        let svg = getDominoSvg(val, 15) + getDominoSvg(val, 15);
        info += `<div class="starter-btn ${active}" onclick="setStarter(${i})">${svg}</div>`;
    }

    info += `</div>`; 
    
    let inputHtml = "";
    let tempInput = game.tempInput;

    if (state.gameKey === 'oldhell' && game.phase === 'score') {
        let isChecked = (tempInput && tempInput[i] === 'true');
        let btnClass = isChecked ? 'made' : 'failed';
        let btnText = isChecked ? 'Made It' : 'Missed';
        
        inputHtml = `<div style="display:flex; align-items:center;">
            <span class="oh-bid-disp">Bid: ${p.bid}</span>
            <button class="oh-toggle-btn ${btnClass}" onclick="toggleOhScore(${i})">${btnText}</button>
        </div>`;
    } 
    else {
        let savedVal = (tempInput && tempInput[i] !== undefined) ? tempInput[i] : '';
        inputHtml = `<input type="number" inputmode="decimal" pattern="[0-9]*" class="p-input" data-idx="${i}" 
            value="${savedVal}" placeholder="${game.phase === 'bid' ? 'Bid' : '0'}" onfocus="this.select()" oninput="clearError()">`;
    }
        
    let helpers = "";
    if (state.gameKey === 'qwirkle') {
        helpers = renderHelpers(i);
    }
    
    if (state.gameKey === 'spades' && game.phase === 'bid') {
        let isBN = game.tempBlindNil[i];
        let cls = isBN ? 'active' : '';
        helpers = `<button class="spades-bn-btn ${cls}" onclick="toggleBlindNil(${i})">Blind Nil</button>`;
    }
    
    if (state.gameKey === 'hearts') {
        helpers = `<button class="qw-btn qw-moon" onclick="applyMoon(${i})">üåô</button>`;
    }

    row.innerHTML = info + `<div class="input-container">${helpers}${inputHtml}</div>`;
    return row;
}

function startPeek(btn, txt) {
    if(!btn.getAttribute('data-orig')) btn.setAttribute('data-orig', btn.innerText);
    btn.innerText = txt;
    btn.style.background = '#fff';
    btn.style.color = '#2c3e50';
    btn.style.borderColor = '#2c3e50';
}

function endPeek(btn) {
    btn.innerText = btn.getAttribute('data-orig');
    btn.style.background = '';
    btn.style.color = '';
    btn.style.borderColor = '';
}

function renderHelpers(pIdx) {
    const conf = GAMES[state.gameKey];
    if (!conf.helpers) return '';
    let html = `<div class="qw-btn-group">`;
    conf.helpers.forEach(h => {
        let cls = 'qw-btn';
        if(h.id === 'q') cls += ' qw-q';
        if(h.id === 'qq') cls += ' qw-qq';
        if(h.id === 'end') cls += ' qw-end';
        if(h.id === 'joker') cls += ' qw-joker';
        if(h.id === 'out') cls += ' qw-out';
        
        let modSource = state.currentGame ? state.currentGame.modifiers : [];
        if (modSource && modSource[pIdx] && modSource[pIdx].includes(h.id)) {
            cls += ' active';
        }
        
        html += `<button id="btn-${pIdx}-${h.id}" class="${cls}" onclick="toggleHelper(${pIdx}, '${h.id}')">
            ${h.label}<span>${h.text || h.label}</span>
        </button>`;
    });
    html += `</div>`;
    return html;
}

function renderTable() {
    if (!state.currentGame) return;
    const game = state.currentGame;
    const conf = GAMES[state.gameKey];
    const thead = document.getElementById('table-head');
    const tbody = document.getElementById('table-body');
    const tfoot = document.getElementById('table-foot');
    
    let hHtml = `<th>Rd</th>`;
    
    if (state.gameKey === 'oldhell') {
        hHtml = `<th>Cards</th><th>Trump</th>`; 
    }
    
    let showGoalCol = true;
    if (game.randomMap) showGoalCol = false;
    if (state.gameKey === 'qwirkle' || state.gameKey === 'oldhell' || state.gameKey === 'rummikub' || state.gameKey === 'triominos') showGoalCol = false;
    if (state.gameKey === 'spades') showGoalCol = false; 
    
    if(showGoalCol) hHtml += `<th>Goal</th>`;
    
    let useTeams = game.settings.useTeams;

    if (useTeams) {
        let teamCount = game.players.length / 2;
        for(let t=0; t<teamCount; t++) {
            let p1Name = game.players[t*2].name;
            let p2Name = game.players[t*2+1].name;
            hHtml += `<th>${p1Name} & ${p2Name}</th>`;
        }
    } else {
        game.players.forEach(p => hHtml += `<th>${p.name}</th>`);
    }
    
    thead.innerHTML = hHtml;
    
    const history = game.history;

    tbody.innerHTML = '';
    history.forEach((h, rIdx) => {
        let tr = document.createElement('tr');
        
        let ctx = game.getRoundDescription(0, rIdx); 
        
        if (state.gameKey === 'oldhell') {
            // Hand size is stored in label for old hell
        } else if (state.gameKey === 'mexicantrain') {
             // Redundant? Class handles it
        } else if (h.trump) ctx = `<span style="font-size:1.5em; color:${(h.trump==='H'||h.trump==='D')?'red':'black'}">${getSuitIcon(h.trump)}</span>`;
        else if (h.isBid) ctx = "Bids";
        
        if (ctx) ctx = ctx.replace(', ', '<br>');
        
        let rowHtml = `<td>${h.label}</td>`;
        
        if (state.gameKey === 'oldhell') {
            let tIcon = h.trump ? `<span style="color:${(h.trump==='H'||h.trump==='D')?'red':'black'}">${getSuitIcon(h.trump)}</span>` : '';
            rowHtml += `<td style="font-size:1.2em">${tIcon}</td>`;
        }
        
        if(showGoalCol) rowHtml += `<td class="contract-text">${ctx}</td>`;
        tr.innerHTML = rowHtml;
        
        if (useTeams) {
            let teamCount = game.players.length / 2;
            for(let t=0; t<teamCount; t++) {
                let p1Idx = t*2;
                let p2Idx = t*2+1;
                let valToDisplay = 0;
                
                if (h.isBid) {
                    let b1 = h.scores[p1Idx];
                    let b2 = h.scores[p2Idx];
                    valToDisplay = `${b1} / ${b2}`;
                } else {
                    if (state.gameKey === 'spades') {
                        if (h.isComplete) {
                            let b1 = h.bids[p1Idx];
                            let b2 = h.bids[p2Idx];
                            let t1 = h.tricks[p1Idx];
                            let t2 = h.tricks[p2Idx];
                            let score = h.scores[p1Idx]; 
                            
                            valToDisplay = `<div class="spades-cell">
                                <div class="spades-details">
                                    <span class="s-label">B: ${b1}/${b2}</span>
                                    <span class="s-label">T: ${t1}/${t2}</span>
                                </div>
                                <div class="spades-score">${score}</div>
                            </div>`;
                        } else {
                            valToDisplay = h.scores[p1Idx];
                        }
                    } else {
                        // SHANGHAI TEAM DISPLAY WITH RANDOM GOALS
                        let scoreSum = h.scores[p1Idx] + h.scores[p2Idx];
                        if (state.gameKey === 'shanghai' && game.randomMap) {
                            let g = game.randomMap[p1Idx][rIdx];
                            valToDisplay = `<div style="font-size:0.75em; color:#555; margin-bottom:4px;">${g}</div>
                            <span style="font-weight:bold">${scoreSum}</span>`;
                        } else {
                            valToDisplay = scoreSum;
                        }
                    }
                }
                tr.innerHTML += `<td>${valToDisplay}</td>`;
            }
        } else {
            h.scores.forEach((s, i) => {
                let cls = (i === h.dealerIdx) ? 'history-dealer' : '';
                
                let content = s;

                // SPECIAL OLD HELL RENDER
                if (state.gameKey === 'oldhell' && h.isComplete) {
                    let bid = h.bids[i];
                    let score = h.scores[i];
                    let colorClass = (score > 0) ? 'oh-made' : 'oh-missed'; 
                    content = `<div class="oh-cell ${colorClass}">
                        <span>${bid}</span><span>${score}</span>
                    </div>`;
                } 
                // SPECIAL SPADES RENDER (Merged Row)
                else if (state.gameKey === 'spades' && h.isComplete) {
                    let bid = h.bids[i];
                    let trick = h.tricks[i];
                    let score = h.scores[i];
                    
                    content = `<div class="spades-cell">
                        <div class="spades-details">
                            <span class="s-label">B: ${bid}</span>
                            <span class="s-label">T: ${trick}</span>
                        </div>
                        <div class="spades-score">${score}</div>
                    </div>`;
                }
                else {
                    if (h.starFlags && h.starFlags[i]) content = `${content}<span class="history-star">‚òÖ</span>`;
                    
                    if (h.meta && h.meta.mods && h.meta.mods[i]) {
                        h.meta.mods[i].forEach(m => {
                            if(m==='q') content += '<span class="badge-q">Q</span>';
                            if(m==='qq') content += '<span class="badge-qq">QQ</span>';
                            if(m==='end') content += '<span class="badge-end">üèÅ</span>';
                        });
                    }
                    if(game.randomMap) {
                        content += `<span class="table-sub">${game.randomMap[i][rIdx]}</span>`;
                    }
                }

                tr.innerHTML += `<td class="${cls}">${content}</td>`;
            });
        }
        tbody.appendChild(tr);
    });
    
    let fHtml = `<td>Tot</td>`;
    if(state.gameKey === 'oldhell') fHtml += `<td></td>`;
    if(showGoalCol) fHtml += `<td></td>`;
    
    if (useTeams) {
        let teamCount = game.players.length / 2;
        for(let t=0; t<teamCount; t++) {
            let p1Total = game.players[t*2].total;
            let p2Total = game.players[t*2+1].total;
            let combined = 0;
            if (state.gameKey === 'spades') combined = p1Total; 
            else combined = p1Total + p2Total; 
            fHtml += `<td>${combined}</td>`;
        }
    } else {
        game.players.forEach(p => fHtml += `<td>${p.total}</td>`);
    }
    tfoot.innerHTML = fHtml;
}

function captureInputs() {
    const inputs = document.querySelectorAll('.p-input');
    if (state.currentGame) {
        state.currentGame.tempInput = [];
        inputs.forEach((inp, i) => { state.currentGame.tempInput[i] = inp.value; });
    }
}

function toggleOhScore(idx) {
    if(!state.currentGame) return;
    if(!state.currentGame.tempInput) state.currentGame.tempInput = [];
    let current = state.currentGame.tempInput[idx] === 'true';
    state.currentGame.tempInput[idx] = (!current).toString();
    renderGame();
}

function toggleBlindNil(idx) {
    let inputEl = document.querySelector(`.p-input[data-idx="${idx}"]`);
    if(inputEl && inputEl.value !== "" && inputEl.value !== "0") {
        alert("Blind Nil requires a bid of 0.");
        return;
    }
    if(inputEl) inputEl.value = "0";
    
    if (state.currentGame && state.currentGame.toggleBlindNil) {
        state.currentGame.toggleBlindNil(idx);
    }
    renderGame();
}

function applyMoon(idx) {
    let inputs = document.querySelectorAll('.p-input');
    inputs.forEach((inp, i) => {
        if (i === idx) inp.value = "0";
        else inp.value = "26";
    });
    captureInputs(); // Ensure UI state is saved
}

function submitRound() {
    const inputs = document.querySelectorAll('.p-input');
    const err = document.getElementById('error-msg');
    
    if (!state.currentGame) return;

    let rawValues = [];
    
    // Special case for Old Hell Scoring (No DOM inputs, use tempInput)
    if (state.gameKey === 'oldhell' && state.currentGame.phase === 'score') {
        for(let i=0; i<state.currentGame.players.length; i++) {
            let val = (state.currentGame.tempInput && state.currentGame.tempInput[i]) ? state.currentGame.tempInput[i] : 'false';
            rawValues.push(val);
        }
    } else {
        inputs.forEach(inp => rawValues.push(inp.value));
    }
    
    let result = state.currentGame.submitRound(rawValues, state.currentGame.modifiers);
    
    if (!result.valid) {
        err.innerText = result.msg;
        err.style.display = 'block';
    } else {
        saveState();
        renderGame();
    }
}

function undoRound() {
    if (!confirm("Undo last step?")) return;
    if (state.currentGame) {
        state.currentGame.undo();
        saveState();
        renderGame();
    }
}

function toggleStar(idx) {
    if(state.gameKey !== 'oldhell') captureInputs(); 
    if (state.currentGame) {
        state.currentGame.currentStars[idx] = !state.currentGame.currentStars[idx];
    }
    renderGame();
}

function toggleHelper(pIdx, modId) {
    captureInputs();
    
    let modSource = state.currentGame.modifiers;
    if (!modSource[pIdx]) modSource[pIdx] = [];
    let list = modSource[pIdx];
    
    if (list.includes(modId)) {
        list = list.filter(m => m !== modId);
    } else {
        const def = GAMES[state.gameKey].helpers.find(h => h.id === modId);
        
        if (modId === 'q' && list.includes('qq')) list = list.filter(m=>m!=='qq');
        if (modId === 'qq' && list.includes('q')) list = list.filter(m=>m!=='q');
        if (def.isEnd) {
            if(confirm("Did this player end the game?")) list.push(modId);
        } else {
            list.push(modId);
        }
    }
    state.currentGame.modifiers[pIdx] = list;
    
    if (state.gameKey === 'rummikub' && modId === 'out' && list.includes('out')) {
        let el = document.querySelector(`.p-input[data-idx="${pIdx}"]`);
        if(el) el.value = "0";
    }
    renderGame();
}

function setStarter(idx) {
    captureInputs();
    if(state.currentGame && state.currentGame.setStarter) {
        state.currentGame.setStarter(idx);
    }
    renderGame();
}

function getSuitIcon(s) {
    if(s==='S') return '‚ô†'; if(s==='C') return '‚ô£'; if(s==='H') return '‚ô•'; if(s==='D') return '‚ô¶'; return '';
}

function renderTrumpSelector() {
    let suits = ['S','H','C','D'];
    let html = `<div class="oh-trump-row">`;
    suits.forEach(s => {
        let currentT = state.currentGame.currentTrump;
        let cls = (currentT === s) ? 'selected' : '';
        let color = (s==='H'||s==='D') ? 'red' : 'black';
        html += `<button class="oh-trump-btn ${cls}" onclick="setTrump('${s}')" style="color:${color}">${getSuitIcon(s)}</button>`;
    });
    html += `</div>`;
    return html;
}
function setTrump(t) { 
    captureInputs(); 
    if (state.currentGame) {
        state.currentGame.setTrump(t);
    }
    renderGame(); 
}

function getDominoSvg(val, size) {
    const grid = {
        TL: [25, 25], TM: [50, 25], TR: [75, 25],
        ML: [25, 50], MM: [50, 50], MR: [75, 50],
        BL: [25, 75], BM: [50, 75], BR: [75, 75]
    };
    const layouts = {
        0: [], 1: [grid.MM], 2: [grid.TR, grid.BL], 3: [grid.TR, grid.MM, grid.BL],
        4: [grid.TL, grid.TR, grid.BL, grid.BR], 5: [grid.TL, grid.TR, grid.MM, grid.BL, grid.BR],
        6: [grid.TL, grid.TR, grid.ML, grid.MR, grid.BL, grid.BR],
        7: [grid.TL, grid.TR, grid.ML, grid.MM, grid.MR, grid.BL, grid.BR],
        8: [grid.TL, grid.TM, grid.TR, grid.ML, grid.MR, grid.BL, grid.BM, grid.BR],
        9: [grid.TL, grid.TM, grid.TR, grid.ML, grid.MM, grid.MR, grid.BL, grid.BM, grid.BR],
        10: [[25,20],[75,20],[50,20],[25,80],[75,80],[50,80],[25,40],[75,40],[25,60],[75,60]], 
        11: [[25,20],[75,20],[50,20],[25,80],[75,80],[50,80],[25,40],[75,40],[25,60],[75,60],[50, 50]],
        12: [[25, 20], [50, 20], [75, 20], [25, 40], [50, 40], [75, 40], [25, 60], [50, 60], [75, 60], [25, 80], [50, 80], [75, 80]]
    };
    let dots = (layouts[val]||[]).map(p=>`<circle cx="${p[0]}" cy="${p[1]}" r="9" fill="${DOMINO_COLORS[val]}"/>`).join('');
    return `<svg width="${size}" height="${size}" viewBox="0 0 100 100" style="background:white; border:1px solid #333; margin:1px; border-radius:3px">${dots}</svg>`;
}

function saveState() { 
    if (!state.currentGame) return;
    
    // Save Class State
    let dataToSave = {
        gameKey: state.gameKey,
        classData: {
            players: state.currentGame.players,
            history: state.currentGame.history,
            round: state.currentGame.round,
            dealCount: state.currentGame.dealCount,
            isGameOver: state.currentGame.isGameOver,
            randomMap: state.currentGame.randomMap,
            phase: state.currentGame.phase,
            handSize: state.currentGame.handSize,
            currentTrump: state.currentGame.currentTrump,
            manualStarter: state.currentGame.manualStarter 
        }
    };
    localStorage.setItem('cardScorerSave', JSON.stringify(dataToSave)); 
}

function checkRestore() { 
    if(localStorage.getItem('cardScorerSave')) document.getElementById('restore-btn').style.display='block'; 
    else document.getElementById('restore-btn').style.display='none'; 
}

function restoreGame() {
    let s = localStorage.getItem('cardScorerSave');
    if(s) { 
        let parsed = JSON.parse(s);
        state.gameKey = parsed.gameKey; // Ensure correct game is loaded
        
        const conf = GAMES[state.gameKey];
        const cd = parsed.classData;
        
        // Re-hydrate Class
        if (state.gameKey === 'shanghai') {
            state.currentGame = new ShanghaiGame(conf, cd.players, { useTeams: false }); 
        } else if (state.gameKey === 'spades') {
            state.currentGame = new SpadesGame(conf, cd.players, { useTeams: false });
        } else if (state.gameKey === 'oldhell') {
            state.currentGame = new OldHellGame(conf, cd.players, { useTeams: false });
        } else if (state.gameKey === 'hearts') {
            state.currentGame = new HeartsGame(conf, cd.players, {});
        } else if (state.gameKey === 'mexicantrain') {
            state.currentGame = new MexicanTrainGame(conf, cd.players, {});
        } else if (state.gameKey === 'rummikub') {
            state.currentGame = new RummikubGame(conf, cd.players, {});
        } else if (state.gameKey === 'triominos') {
            state.currentGame = new TriominosGame(conf, cd.players, {});
        } else {
            state.currentGame = new SimpleScoreGame(conf, cd.players, {});
        }
        
        // Restore Props
        Object.assign(state.currentGame, cd);
        // Important: Re-link players array for simple access if needed (though UI uses game.players)
        
        // Setup UI for this game
        document.getElementById('game-select').value = state.gameKey;
        updateSetupUI(); // Triggers UI update based on key
        
        renderGame(); 
        document.getElementById('setup-screen').style.display='none'; 
        document.getElementById('game-screen').style.display='block'; 
    }
}

function confirmExit() {
    let isFinished = state.currentGame ? state.currentGame.isGameOver : false;

    if(isFinished) {
        finalizeGame();
    } else {
        let msg = "End game and calculate winner?";
        if (state.gameKey !== 'rummikub' && state.gameKey !== 'triominos' && state.gameKey !== 'qwirkle') msg = "Exit game early? (No stats will be recorded)";
        
        if(confirm(msg)) {
            if (state.gameKey === 'rummikub' || state.gameKey === 'triominos' || state.gameKey === 'qwirkle') {
                if(state.currentGame) state.currentGame.isGameOver = true;
                finalizeGame(); 
            } else {
                localStorage.removeItem('cardScorerSave');
                location.reload();
            }
        }
    }
}

function finalizeGame() {
    if (!state.currentGame) return;
    const conf = GAMES[state.gameKey];
    const totals = state.currentGame.players.map(p => p.total);
    let bestScore = (conf.type === 'low_score') ? Math.min(...totals) : Math.max(...totals);
    let winners = state.currentGame.players.filter(p => p.total === bestScore).map(p => p.name);
    
    let lb = JSON.parse(localStorage.getItem('cardScorerLB') || '{}');
    if (!lb[state.gameKey]) lb[state.gameKey] = {};
    
    state.currentGame.players.forEach(p => {
        let pName = p.name;
        // Migration: If data is old number, convert to object
        if (typeof lb[state.gameKey][pName] === 'number') {
            lb[state.gameKey][pName] = { wins: lb[state.gameKey][pName], plays: lb[state.gameKey][pName], best: null };
        }
        
        // Initialize if new
        if (!lb[state.gameKey][pName]) {
            lb[state.gameKey][pName] = { wins: 0, plays: 0, best: null };
        }
        
        let stats = lb[state.gameKey][pName];
        stats.plays++;
        
        if (winners.includes(pName)) {
            stats.wins++;
        }
        
        // Update Personal Best
        let pTotal = p.total;
        if (stats.best === null) {
            stats.best = pTotal;
        } else {
            if (conf.type === 'low_score') {
                if (pTotal < stats.best) stats.best = pTotal;
            } else {
                if (pTotal > stats.best) stats.best = pTotal;
            }
        }
    });
    
    localStorage.setItem('cardScorerLB', JSON.stringify(lb));
    localStorage.removeItem('cardScorerSave');
    
    state.currentGame = null;
    
    document.getElementById('restore-btn').style.display = 'none';
    showLeaderboard();
}

function showLeaderboard() {
    document.getElementById('setup-screen').style.display='none';
    document.getElementById('game-screen').style.display='none';
    document.getElementById('leaderboard-screen').style.display='block';
    
    const lb = JSON.parse(localStorage.getItem('cardScorerLB') || '{}');
    const div = document.getElementById('lb-content');
    div.innerHTML = '';
    
    for(let k in GAMES) {
        let title = document.createElement('div');
        title.className = 'lb-title';
        title.innerHTML = `<span>${GAMES[k].name}</span> <button class="btn-lb-reset" onclick="resetLB('${k}')">Clear</button>`;
        div.appendChild(title);
        
        let rawData = lb[k] || {};
        // Convert old simple data to new structure for display if needed
        let entries = Object.entries(rawData).map(([name, val]) => {
            if (typeof val === 'number') return { name, wins: val, plays: val, best: '-' };
            return { name, ...val };
        });
        
        // Sort by Wins
        entries.sort((a,b) => b.wins - a.wins);
        
        if(!entries.length) div.innerHTML += `<div style="color:#999;font-style:italic;margin-bottom:20px">No stats yet</div>`;
        else {
            let table = `<table class="lb-table">
                <thead><tr><th>Name</th><th>Wins</th><th>%</th><th>Best</th></tr></thead>
                <tbody>`;
                
            entries.forEach(e => {
                let pct = (e.plays > 0) ? Math.round((e.wins / e.plays) * 100) + '%' : '-';
                let best = (e.best !== null && e.best !== '-') ? e.best : '-';
                table += `<tr>
                    <td>${e.name}</td>
                    <td><span class="lb-win-badge">${e.wins}</span></td>
                    <td>${pct}</td>
                    <td>${best}</td>
                </tr>`;
            });
            table += `</tbody></table>`;
            div.innerHTML += table;
        }
    }
}

// ============================================
//   DATA BACKUP SYSTEM
// ============================================

function exportData() {
    const backup = {
        save: localStorage.getItem('cardScorerSave'),
        lb: localStorage.getItem('cardScorerLB'),
        timestamp: new Date().toISOString()
    };
    const dataStr = JSON.stringify(backup);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    const exportFileDefaultName = `game_scorer_backup_${new Date().toISOString().slice(0,10)}.json`;
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
}

function triggerImport() {
    document.getElementById('import-file').click();
}

function importData(input) {
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const content = e.target.result;
            const backup = JSON.parse(content);
            if (confirm("This will OVERWRITE your current history. Continue?")) {
                if (backup.save) localStorage.setItem('cardScorerSave', backup.save);
                if (backup.lb) localStorage.setItem('cardScorerLB', backup.lb);
                alert("Backup restored successfully!");
                location.reload();
            }
        } catch (err) {
            alert("Error loading file: " + err);
        }
    };
    reader.readAsText(file);
    input.value = ''; 
}

function closeLeaderboard() {
    resetTheme(); 
    document.getElementById('leaderboard-screen').style.display='none';
    document.getElementById('setup-screen').style.display='block';
    checkRestore();
}
function resetLB(key) {
    if(!confirm("Reset history for this game?")) return;
    let lb = JSON.parse(localStorage.getItem('cardScorerLB') || '{}');
    lb[key] = {};
    localStorage.setItem('cardScorerLB', JSON.stringify(lb));
    showLeaderboard();
}
function clearLeaderboard() {
    if(!confirm("Reset ALL history?")) return;
    localStorage.removeItem('cardScorerLB');
    showLeaderboard();
}
function clearError() { document.getElementById('error-msg').style.display='none'; }
</script>
</body>
</html>
